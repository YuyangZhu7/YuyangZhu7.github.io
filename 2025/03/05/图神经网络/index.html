<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/show.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/show.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/show.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuyangzhu7.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="title:”图神经网络”data:2025-3-5author:”朱宇阳”深度学习-图神经网络学习笔记,欢迎访问我的主页">
<meta property="og:type" content="article">
<meta property="og:title" content="Yarn&#39;s blog">
<meta property="og:url" content="https://yuyangzhu7.github.io/2025/03/05/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Yarn&#39;s blog">
<meta property="og:description" content="title:”图神经网络”data:2025-3-5author:”朱宇阳”深度学习-图神经网络学习笔记,欢迎访问我的主页">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pic3.zhimg.com/v2-9e036b9bd672e5e396db074db214f0e8_1440w.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/v2-19dc97280205625dcc802f9130aa66bd_1440w.jpg">
<meta property="og:image" content="file:///C:/Users/%E6%9C%B1%E5%AE%87%E9%98%B3/AppData/Local/Temp/ksohtml8804/wps1.jpg">
<meta property="og:image" content="https://pica.zhimg.com/v2-8bb65d0bfb5f9efc2d9d791fbb548a9c_r.jpg">
<meta property="og:image" content="c:\Users\%E6%9C%B1%E5%AE%87%E9%98%B3\AppData\Roaming\Typora\typora-user-images\1741093107548.png">
<meta property="og:image" content="c:\Users\%E6%9C%B1%E5%AE%87%E9%98%B3\AppData\Roaming\Typora\typora-user-images\1741093130383.png">
<meta property="og:image" content="c:\Users\%E6%9C%B1%E5%AE%87%E9%98%B3\AppData\Roaming\Typora\typora-user-images\1741093130383.png">
<meta property="og:image" content="https://picx.zhimg.com/v2-15fea61b768f7561648dbea164fcb75f_b.webp">
<meta property="article:published_time" content="2025-03-05T05:13:43.992Z">
<meta property="article:modified_time" content="2025-03-10T06:01:35.194Z">
<meta property="article:author" content="Yarn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic3.zhimg.com/v2-9e036b9bd672e5e396db074db214f0e8_1440w.jpg">

<link rel="canonical" href="https://yuyangzhu7.github.io/2025/03/05/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | Yarn's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Yarn's blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
   <a target="_blank" rel="noopener" href="https://github.com/you" style="position: fixed; top: 0; right: 0; text-decoration: none; border: none; padding: 0;">
  <img decoding="async" width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" style="border: none; margin: 0; padding: 0;">
</a>



    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yarn's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuyangzhu7.github.io/2025/03/05/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/me.png">
      <meta itemprop="name" content="Yarn">
      <meta itemprop="description" content="Yarn的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yarn's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-03-05 13:13:43" itemprop="dateCreated datePublished" datetime="2025-03-05T13:13:43+08:00">2025-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-03-10 14:01:35" itemprop="dateModified" datetime="2025-03-10T14:01:35+08:00">2025-03-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<h2 id="title-”图神经网络”data-2025-3-5author-”朱宇阳”"><a href="#title-”图神经网络”data-2025-3-5author-”朱宇阳”" class="headerlink" title="title:”图神经网络”data:2025-3-5author:”朱宇阳”"></a>title:”图神经网络”<br>data:2025-3-5<br>author:”朱宇阳”</h2><p>深度学习-图神经网络学习笔记,欢迎访问我的<a href="https://yuyangzhu7.github.io/">主页</a></p>
<span id="more"></span> 



<h1 id="图神经网络概述"><a href="#图神经网络概述" class="headerlink" title="图神经网络概述"></a>图神经网络概述</h1><p>随着机器学习、深度学习的发展，语音、图像、自然语言处理逐渐取得了很大的突破，然而语音、图像、文本都是很简单的序列或者网格数据，是很结构化的数据，深度学习很善于处理该种类型的数据。然而现实世界中并不是所有的事物都可以表示成一个序列或者一个网格，例如社交网络、知识图谱、复杂的文件系统等，也就是说很多事物都是非结构化的。</p>
<p>相比于简单的文本和图像，这种网络类型的非结构化的数据非常复杂，处理它的难点包括：</p>
<ul>
<li><p>图的大小是任意的，图的拓扑结构复杂，没有像图像一样的空间局部性</p>
</li>
<li><p>图没有固定的节点顺序，或者说没有一个参考节点</p>
</li>
<li><p>图经常是动态图，而且包含多模态的特征</p>
</li>
</ul>
<p>相比较于神经网络最基本的网络结构全连接层（MLP），特征矩阵乘以权重矩阵，图神经网络多了一个邻接矩阵。计算形式很简单，三个矩阵相乘再加上一个非线性变换（图3）。</p>
<p>  <img src="https://pic3.zhimg.com/v2-9e036b9bd672e5e396db074db214f0e8_1440w.jpg" alt="img"></p>
<p>  因此一个比较常见的图神经网络的应用模式如下图，输入是一个图，经过多层图卷积等各种操作以及激活函数，最终得到各个节点的表示，以便于进行节点分类、链接预测、图与子图的生成等等任务。</p>
<p>  <img src="https://pic2.zhimg.com/v2-19dc97280205625dcc802f9130aa66bd_1440w.jpg" alt="img"></p>
<h1 id="GCN"><a href="#GCN" class="headerlink" title="GCN"></a>GCN</h1><p>GCN的本质目的就是用来提取拓扑图的空间特征。 而图卷积神经网络主要有两类，一类是基于空间域或顶点域vertex domain(spatial domain)的，另一类则是基于频域或谱域spectral domain的。通俗点解释，空域可以类比到直接在图片的像素点上进行卷积，而频域可以类比到对图片进行<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=192209974&content_type=Article&match_order=1&q=%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2&zhida_source=entity">傅里叶变换</a>后，再进行卷积。所谓的两类其实就是从两个不同的角度理解，关于从空间角度的理解可以看本文的从空间角度理解GCN</p>
<h2 id="一-顶点域（空间域）"><a href="#一-顶点域（空间域）" class="headerlink" title="一.顶点域（空间域）"></a>一.顶点域（空间域）</h2><p>基于空域卷积的方法直接将卷积操作定义在每个结点的连接关系上，它跟传统的卷积神经网络中的卷积更相似一些。在这个类别中比较有代表性的方法有</p>
<p>这段话主要介绍了图神经网络（GNN）中一种基于<strong>空域卷积</strong>（Spatial Convolution）的核心思想及其代表性方法。以下是对这段话的逐层解析：</p>
<hr>
<h3 id="1-核心概念：空域卷积"><a href="#1-核心概念：空域卷积" class="headerlink" title="1. 核心概念：空域卷积"></a><strong>1. 核心概念：空域卷积</strong></h3><ul>
<li><strong>与传统卷积的区别</strong>：<ul>
<li>在传统卷积神经网络（CNN）中，卷积操作是<strong>固定在网格状数据</strong>（如图像、音频）上的局部模式匹配（通过滑动窗口提取特征）。例如，图像的卷积核会在像素的二维平面上滑动。</li>
<li><strong>空域卷积</strong>则针对<strong>图结构数据</strong>（非欧几里得空间），将卷积操作直接定义在<strong>节点的连接关系</strong>（即图的邻接关系）上。它的核心是<strong>聚合节点及其邻居的信息</strong>，而非固定窗口内的像素。</li>
</ul>
</li>
<li><strong>关键特点</strong>：<ul>
<li><strong>动态邻域</strong>：每个节点的“感受野”由其邻居决定，而非固定的网格位置。</li>
<li><strong>图同构不变性</strong>：卷积操作能适应图的拓扑结构变化（如不同形状的分子结构）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-典型方法：空域卷积的代表模型"><a href="#2-典型方法：空域卷积的代表模型" class="headerlink" title="2. 典型方法：空域卷积的代表模型"></a><strong>2. 典型方法：空域卷积的代表模型</strong></h3><p>以下方法均通过不同的方式实现了空域卷积的思想：</p>
<h4 id="1-Message-Passing-Neural-Networks-MPNN-1"><a href="#1-Message-Passing-Neural-Networks-MPNN-1" class="headerlink" title="(1) Message Passing Neural Networks (MPNN) [1]"></a><strong>(1) Message Passing Neural Networks (MPNN)</strong> [1]</h4><ul>
<li>思想：明确提出了消息传递框架（Message Passing），将节点间的信息交互建模为两步：<ol>
<li><strong>消息传递</strong>：节点将自己的特征与邻居的特征结合，生成新的消息。</li>
<li><strong>聚合</strong>：节点将接收到的所有邻居的消息进行聚合（如求和、均值），更新自身特征。</li>
</ol>
</li>
<li><strong>优势</strong>：提供了统一的图神经网络建模范式，被许多后续研究继承（如GCN）。</li>
</ul>
<h4 id="2-GraphSAGE-2"><a href="#2-GraphSAGE-2" class="headerlink" title="(2) GraphSAGE [2]"></a><strong>(2) GraphSAGE</strong> [2]</h4><ul>
<li>思想：采用归纳式学习（Inductive Learning），通过聚合节点的局部邻居信息生成节点嵌入。其核心步骤包括：<ol>
<li>节点采样邻居（如随机选取固定数量的邻居）。</li>
<li>聚合邻居特征并更新当前节点表示。</li>
</ol>
</li>
<li><strong>优势</strong>：<br>计算高效，支持大规模图的训练（如社交网络）。</li>
</ul>
<h4 id="3-Diffusion-Convolution-Neural-Networks-DCNN-3"><a href="#3-Diffusion-Convolution-Neural-Networks-DCNN-3" class="headerlink" title="(3) Diffusion Convolution Neural Networks (DCNN) [3]"></a><strong>(3) Diffusion Convolution Neural Networks (DCNN)</strong> [3]</h4><ul>
<li><strong>思想</strong>：<br>将卷积操作与<strong>扩散过程</strong>​（Diffusion Process）结合。通过多轮扩散（类似热传导），将节点的局部信息逐步传播到整个图，形成全局感知的特征。</li>
<li><strong>数学形式</strong>：<br>使用图的拉普拉斯矩阵的幂次（<em>L**k</em>）对节点特征进行变换，隐式地模拟了信息扩散的步数 <em>k</em>。</li>
<li><strong>优势</strong>：<br>明确关联了卷积操作与图的谱分解（频域方法），但计算成本较高。</li>
</ul>
<h4 id="4-PATCHY-SAN-4"><a href="#4-PATCHY-SAN-4" class="headerlink" title="(4) PATCHY-SAN [4]"></a><strong>(4) PATCHY-SAN</strong> [4]</h4><ul>
<li>思想：将图划分为若干个小块（PATCHES），并在每个小块内应用类似于CNN的局部卷积操作。具体步骤：<ol>
<li>对图进行超图划分，提取节点及其邻居组成的子图（PATCH）。</li>
<li>在每个PATCH内对节点特征进行卷积（如权重共享的全连接层）。</li>
<li>汇总所有PATCH的结果生成全局特征。</li>
</ol>
</li>
<li><strong>优势</strong>：<br>直接复用CNN的成熟架构，增强了对局部结构的建模能力。</li>
</ul>
<p><img src="file:///C:\Users\朱宇阳\AppData\Local\Temp\ksohtml8804\wps1.jpg" alt="img"> </p>
<h2 id="二-spectral-domain：频域方法（谱方法）"><a href="#二-spectral-domain：频域方法（谱方法）" class="headerlink" title="二. spectral domain：频域方法（谱方法）"></a>二. spectral domain：频域方法（谱方法）</h2><p>这就是谱域图卷积网络的理论基础了。这种思路就是希望借助图谱的理论来实现拓扑图上的卷积操作。从整个研究的时间进程来看：首先研究GSP（graph signal processing）的学者定义了graph上的Fourier Transformation，进而定义了graph上的convolution，最后与深度学习结合提出了Graph Convolutional Network。</p>
<p>基于频域卷积的方法则从<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=192209974&content_type=Article&match_order=1&q=%E5%9B%BE%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86&zhida_source=entity">图信号处理</a>起家，包括 Spectral CNN[5], Cheybyshev Spectral CNN(ChebNet)[6], 和 First order of ChebNet(1stChebNet)[7]　等。论文Semi-Supervised Classification with Graph Convolutional Networks就是一阶邻居的ChebNet。认真读到这里，脑海中应该会浮现出一系列问题：</p>
<h3 id="1-基础导引"><a href="#1-基础导引" class="headerlink" title="1.基础导引"></a>1.基础导引</h3><p><strong>Q1 什么是</strong><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=192209974&content_type=Article&match_order=1&q=Spectral+graph+theory&zhida_source=entity"><strong>Spectral graph theory</strong></a><strong>？</strong></p>
<p>Spectral graph theory请参考维基百科的介绍，简单的概括就是借助于图的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=192209974&content_type=Article&match_order=1&q=%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%9F%A9%E9%98%B5&zhida_source=entity">拉普拉斯矩阵</a>的特征值和特征向量来研究图的性质</p>
<p><strong>Q2 GCN为什么要利用Spectral graph theory？</strong>这是论文（<strong>Semi-Supervised Classification with Graph Convolutional Networks</strong>）中的重点和难点，要理解这个问题需要大量的数学定义及推导</p>
<p>过程：</p>
<p>（1）定义graph上的Fourier Transformation傅里叶变换（利用Spectral graph theory，借助图的拉普拉斯矩阵的特征值和特征向量研究图的性质）</p>
<p>（2）定义graph上的convolution卷积</p>
<h2 id="三-频域方法下图卷积网络的推导"><a href="#三-频域方法下图卷积网络的推导" class="headerlink" title="三.频域方法下图卷积网络的推导"></a>三.频域方法下图卷积网络的推导</h2><h3 id="1-拉普拉斯矩阵"><a href="#1-拉普拉斯矩阵" class="headerlink" title="1.拉普拉斯矩阵"></a>1.拉普拉斯矩阵</h3><p> 拉普拉斯矩阵，主要应用在图论中，作为一个图的矩阵表示。对于图 G&#x3D;(V,E)，其Laplacian 矩阵的定义为 L&#x3D;D-A，</p>
<blockquote>
<p>其中 L 是Laplacian 矩阵，D&#x3D;diag(d)是顶点的度矩阵,对角线上元素依次为各个顶点的度，<br>A 是图的邻接矩阵。 频域卷积的前提条件是图必须是无向图，只考虑无向图，那么L就是对称矩阵。 </p>
</blockquote>
<p> <img src="https://pica.zhimg.com/v2-8bb65d0bfb5f9efc2d9d791fbb548a9c_r.jpg" alt="img"> </p>
<p><img src="C:\Users\朱宇阳\AppData\Roaming\Typora\typora-user-images\1741093107548.png" alt="1741093107548" style="zoom: 67%;" /><img src="C:\Users\朱宇阳\AppData\Roaming\Typora\typora-user-images\1741093130383.png" alt="1741093130383"></p>
<img src="C:\Users\朱宇阳\AppData\Roaming\Typora\typora-user-images\1741093130383.png" alt="1741093130383" style="zoom:70%;" />

<p>（1）拉普拉斯矩阵是半正定矩阵。（最小特征值大于等于0）</p>
<p>（2）特征值中0出现的次数就是图连通区域的个数。</p>
<p>（3）最小特征值是0，因为拉普拉斯矩阵（普通形式： $L&#x3D;D−A$）每一行的和均为0，并且最小特征值对应的特征向量是每个值全为1的向量；</p>
<p>（4）最小非零特征值是图的代数连通度。</p>
<p>要证明拉普拉斯矩阵是半正定的，只需要证明其二次型$ f^{T} L f \geq 0 $证明：<br>$$<br>\begin{aligned}f^{T} L f &amp;&#x3D;f^{T} D f-f^{T} A f \&amp;&#x3D;f^{T} * \operatorname{diag}(d) * f-f^{T} A f \&amp;&#x3D;\sum_{i&#x3D;1}^{m} d_{i} f_{i}^{2}-\sum_{j&#x3D;1}^{m}\left[\sum_{i&#x3D;1}^{m} f_{j} * a_{i j}\right] f_{j} \&amp;&#x3D;\sum_{i&#x3D;1}^{m} d_{i} f_{i}^{2}-\sum_{i, j&#x3D;1}^{m} f_{i} * f_{j} * a_{i j} \&amp;&#x3D;\frac{1}{2}\left[\sum_{i&#x3D;1}^{m} d_{i} f_{i}^{2}-2 \sum_{i, j&#x3D;1}^{m} f_{i} f_{j} a_{i j}+\sum_{j&#x3D;1}^{m} d_{j} f_{j}^{2}\right] \&amp;&#x3D;\frac{1}{2} \sum_{i, j&#x3D;1}^{m} a_{i j}\left(f_{i}-f_{j}\right)^{2}\end{aligned}<br>$$<br>所以，对于任意一个属于实向量fff都有此公式成立。</p>
<p> <strong>特征分解，又称谱分解</strong>是将<strong>矩阵分解为由其特征值和特征向量表示的矩阵之积的方法</strong>。只有对可对角化矩阵或有n个线性无关的特征向量的矩阵才可以施以特征分解。   不是所有的矩阵都可以特征分解，其充要条件为n阶方阵存在n个线性无关的特征向量。 </p>
<p><strong>拉普拉斯矩阵是半正定矩阵（半正定矩阵本身就是对称矩阵），有如下三个性质：</strong></p>
<ul>
<li>对称矩阵一定n个线性无关的特征向量</li>
<li>半正定矩阵的特征值一定非负</li>
<li>对阵矩阵的不同特征值对应的特征向量相互正交，这些正交的特征向量构成的矩阵为正交矩阵。<br>由上拉普拉斯矩阵对称知一定可以谱分解，且分解后有特殊的形式。</li>
</ul>
<p>对于拉普拉斯矩阵其谱分解为：</p>
<p>$L&#x3D;U \Lambda U^{-1}&#x3D;U \Lambda U^{-1}&#x3D;U\left[\begin{array}{lll}\lambda_{1} &amp; &amp; &amp; \&amp; &amp; \ddots &amp; \&amp; &amp; \lambda_{n}\end{array}\right] U^{-1}$</p>
<p>其中$U&#x3D;\left(\vec{u}<em>{1}, \vec{u}</em>{2}, \cdots, \overrightarrow{u_{n}}\right),$ 是列向量为单位特征向量的矩阵, 也就说 $\vec{u_1}$ 是列向量,$\wedge $是n个特征值构成的对角阵。由于 $U$正交矩阵, 即 $U U^{T}&#x3D;E$, 所以特征分解又可以写成:$L&#x3D;U \Lambda U^{-1}&#x3D;U \Lambda U^{T}$</p>
<h3 id="2-拉普拉斯算子"><a href="#2-拉普拉斯算子" class="headerlink" title="2. 拉普拉斯算子"></a>2. 拉普拉斯算子</h3><p>定义：拉普拉斯算子是n维欧几里德空间中的一个二阶微分算子，定义为<strong>梯度 (∇f)(\nabla f)$(\nabla f) $的散度</strong> (∇⋅f(\nabla \cdot f(\nabla \cdot f, 即 ∇f⋅f)\nabla f \cdot f)\nabla f $\cdot f) $。因此如果fff是二阶可微的实函数，则的拉普拉斯算子 Δ\Delta\Delta 定义为:</p>
<p>$$\Delta f&#x3D;\nabla^{2} f&#x3D;\nabla \cdot \nabla f$$</p>
<p>fff的拉普拉斯算子也是笛卡尔坐标系xix_ix_i中的所有非混合二阶偏导数：</p>
<p>$\Delta f&#x3D;\sum_{i&#x3D;1}^{n} \frac{\partial^{2} f}{\partial x_{i}^{2}}$</p>
<p>函数的拉普拉斯算子也是该函数的黑塞矩阵(是一个多元函数的二阶偏导数构成的方阵)的迹:</p>
<p>$\Delta f&#x3D;\operatorname{tr}(H(f))$</p>
<p><strong>拉普拉斯算子(Laplacian operator) 的物理意义是空间二阶导</strong>, 准确定义是：<strong>标量梯度场中的散度</strong>, 一般可用于描述物理量的流入流出。 比如说在二维空间中的温度传播规律，一般可以用拉普拉斯算子来描述。</p>
<h3 id="3-离散形式的一维卷积"><a href="#3-离散形式的一维卷积" class="headerlink" title="3. 离散形式的一维卷积"></a>3. 离散形式的一维卷积</h3><p>对于定义在整数 $\mathbb{Z} $上的函数 $\mathrm{g}$, 卷积定义为</p>
<p>$ (f * g)(t)&#x3D;\sum_{\tau&#x3D;-\infty}^{\infty} f(\tau) g(t-\tau)$</p>
<p>所谓卷积，其实就是<strong>把一个函数卷(翻)过来，然后与另一个函数求内积</strong>。</p>
<p>对应到不同方面，<strong>卷积</strong>可以有不同的解释：**g 既可以看作我们在深度学习里常说的核(Kernel)，也可以对应到信号处理中的滤波器(Filter)**。而 f 可以是我们所说的机器学习中的特征(Feature)，也可以是信号处理中的信号(Signal)。f和g的卷积 (f∗g)就可以看作是对f的加权求和。下面两个动图就分别对应信号处理与深度学习中卷积操作的过程。</p>
<p> <img src="https://picx.zhimg.com/v2-15fea61b768f7561648dbea164fcb75f_b.webp" alt="动图"> </p>
<h3 id="4-傅里叶变换"><a href="#4-傅里叶变换" class="headerlink" title="4. 傅里叶变换"></a>4. 傅里叶变换</h3><h4 id="4-1-连续形式的傅立叶变换"><a href="#4-1-连续形式的傅立叶变换" class="headerlink" title="4.1 连续形式的傅立叶变换"></a>4.1 连续形式的傅立叶变换</h4><h5 id="4-1-1-如何直观地理解傅立叶变换？"><a href="#4-1-1-如何直观地理解傅立叶变换？" class="headerlink" title="4.1.1 如何直观地理解傅立叶变换？"></a>4.1.1 如何直观地理解傅立叶变换？</h5><p> 傅里叶级数：任何周期函数，只要满足一定条件都可以表示为不同频率的正弦和&#x2F;或余弦之和的形式，该和成为傅里叶级数。</p>
<p>傅里叶变换：任何非周期函数（但该曲线下的面积是有限的），也可以用正弦和&#x2F;或余弦乘以加权函数的积分来表示，在这种情况下的公式就是傅里叶变换。</p>
<p>傅里叶级数与傅里叶变换的关系：周期函数的周期可以趋向无穷大，这样就可以将傅里叶变换看成是傅里叶级数的推广。</p>
<h4 id="4-2傅里叶级数与傅里叶变换"><a href="#4-2傅里叶级数与傅里叶变换" class="headerlink" title="4.2傅里叶级数与傅里叶变换"></a>4.2傅里叶级数与傅里叶变换</h4><h5 id="4-2-1-傅里叶级数的三角形式"><a href="#4-2-1-傅里叶级数的三角形式" class="headerlink" title="4.2.1 傅里叶级数的三角形式"></a>4.2.1 傅里叶级数的三角形式</h5><p>假设 $f(x)$ 是周期为 $T$ 的函数，并且满足傅里叶级数的收敛条件，那么可以写作傅里叶级数：</p>
<p>$$<br>f(x) &#x3D; \frac{a_0}{2} + \sum_{n&#x3D;1}^{+\infty} \left( a_n \cos \frac{2 \pi n x}{T} + b_n \sin \frac{2 \pi n x}{T} \right)<br>$$</p>
<p>其中，系数 $a_0$、$a_n$ 和 $b_n$ 的计算公式为：</p>
<p>$$<br>\begin{gathered}<br>a_0 &#x3D; \frac{2}{T} \int_{x_0}^{x_0 + T} f(x) , dx \<br>a_n &#x3D; \frac{2}{T} \int_{x_0}^{x_0 + T} f(x) \cos \left( \frac{2 \pi n x}{T} \right) dx \<br>b_n &#x3D; \frac{2}{T} \int_{x_0}^{x_0 + T} f(x) \sin \left( \frac{2 \pi n x}{T} \right) dx<br>\end{gathered}<br>$$</p>
<p>• $a_0$：表示函数 $f(x)$ 的平均值。<br>• $a_n$ 和 $b_n$：分别表示余弦和正弦分量的权重。</p>
<h5 id="4-2-2-傅里叶级数的复指数形式"><a href="#4-2-2-傅里叶级数的复指数形式" class="headerlink" title="4.2.2 傅里叶级数的复指数形式"></a>4.2.2 傅里叶级数的复指数形式</h5><p>借助欧拉公式，可以将傅里叶级数的三角形式转换为复指数形式：</p>
<p>$$<br>f(x) &#x3D; \sum_{n&#x3D;-\infty}^{+\infty} c_n e^{i \frac{2 \pi n x}{T}}<br>$$</p>
<p>其中，系数 $c_n$ 的计算公式为：</p>
<p>$$<br>c_n &#x3D; -\frac{1}{T} \int_{-\frac{F}{2}}^{\frac{\tau}{2}} f(x) e^{-i \frac{2 \pi n x}{T}} dx<br>$$</p>
<p><strong>解释</strong>：<br>• 曲线可以理解为无数旋转的叠加，将 $f(x)$ 看作是圆周运动的组合。<br>• $x$ 的不断增大称为<strong>时域</strong>。</p>
<hr>
<h4 id="4-3、傅里叶变换"><a href="#4-3、傅里叶变换" class="headerlink" title="4.3、傅里叶变换"></a>4.3、傅里叶变换</h4><h5 id="4-3-1-一维连续傅里叶变换"><a href="#4-3-1-一维连续傅里叶变换" class="headerlink" title="4.3.1 一维连续傅里叶变换"></a>4.3.1 一维连续傅里叶变换</h5><p>对于定义域为整个时间轴（$-\infty &lt; t &lt; +\infty$）的非周期函数 $f(x)$，无法通过周期拓延将其扩展为周期函数，此时需要用到傅里叶变换：</p>
<p>$$<br>F(u) &#x3D; \int_{-\infty}^{+\infty} f(x) e^{-i 2 \pi u x} dx<br>$$</p>
<p>其中：<br>• $F(u)$ 是 $f(x)$ 的频域表示。<br>• $u$ 是频率，单位为 $1&#x2F;T$。</p>
<p>根据傅里叶反变换公式，可以从频域恢复到时域：</p>
<p>$$<br>f(x) &#x3D; \int_{-\infty}^{+\infty} F(u) e^{i 2 \pi u x} du<br>$$</p>
<h5 id="4-3-2-傅里叶变换与傅里叶级数的关系"><a href="#4-3-2-傅里叶变换与傅里叶级数的关系" class="headerlink" title="4.3.2 傅里叶变换与傅里叶级数的关系"></a>4.3.2 傅里叶变换与傅里叶级数的关系</h5><p>• <strong>对比</strong>：<br>  • 傅里叶级数中的 $a_n$ 和 $b_n$ 是离散的频域系数，而傅里叶变换的结果 $F(u)$ 是连续的频域表示。<br>  • 傅里叶级数是对周期函数的分解，而傅里叶变换适用于非周期函数。</p>
<p>• <strong>频率的连续化</strong>：<br>  • 当周期 $T \to +\infty$ 时，频率 $u &#x3D; 1&#x2F;T$ 趋近于连续变化，因此离散的求和变为积分形式。</p>
<p><strong>总结</strong>：<br>• 傅里叶变换的结果 $F(u)$ 实际上相当于傅里叶级数展开中的傅里叶系数。<br>• 傅里叶反变换公式体现了不同频率复指数函数的加权和形式，只不过这里的频率 $u$ 是连续的，因此采用了积分的形式。</p>
<p>$$<br>h_v &#x3D; f\left(\frac{1}{|\mathcal{N}(v)|} \sum_{u \in \mathcal{N}(v)} W x_u + b\right) \quad \forall v \in \mathcal{V}<br>$$<br><strong>1. 符号解释</strong></p>
<p><strong>节点和邻居</strong><br>• $\mathcal{V}$：图中的所有节点集合。<br>• $\mathcal{N}(v)$：节点 $v$ 的邻居节点集合。<br>• $|\mathcal{N}(v)|$：节点 $v$ 的邻居节点数量（即邻居集合的大小）。</p>
<p><strong>特征表示</strong><br>• $x_u$：节点 $u$ 的特征向量，通常是一个 $d$ 维向量。<br>• $W$：可学习的权重矩阵，维度为 $d \times d’$，用于对节点特征进行线性变换。<br>• $b$：可学习的偏置向量，维度为 $d’$。</p>
<p><strong>聚合与变换</strong><br>• $\sum_{u \in \mathcal{N}(v)}$：对节点 $v$ 的所有邻居节点 $u$ 的特征进行求和。<br>• $\frac{1}{|\mathcal{N}(v)|}$：对邻居节点的特征求和结果进行归一化，确保聚合结果的值与邻居数量无关。</p>
<p><strong>输出特征</strong><br>• $h_v$：节点 $v$ 的输出特征向量，经过聚合和变换后得到。<br>• $f(\cdot)$：激活函数（如 ReLU），用于引入非线性。</p>
<p><strong>2. 公式的含义</strong><br>这个公式描述了 GCN Layer 的核心操作，主要包括以下几个步骤：</p>
<p><strong>(1) 邻居特征的聚合</strong><br>$$<br>\sum_{u \in \mathcal{N}(v)} x_u<br>$$<br>• 对节点 $v$ 的所有邻居节点 $u$ 的特征向量 $x_u$ 进行求和。<br>• 这一步的目的是捕捉节点 $v$ 的局部结构信息，即通过邻居节点的特征来更新节点 $v$ 的表示。</p>
<p><strong>(2) 归一化</strong><br>$$<br>\frac{1}{|\mathcal{N}(v)|} \sum_{u \in \mathcal{N}(v)} x_u<br>$$<br>• 将邻居节点的特征求和结果除以邻居节点的数量 $|\mathcal{N}(v)|$，进行归一化。<br>• 归一化的目的是避免节点特征的聚合结果受到邻居数量的影响。例如，某些节点可能有很多邻居，而另一些节点可能只有很少的邻居。</p>
<p><strong>(3) 线性变换</strong><br>$$<br>W \cdot \left(\frac{1}{|\mathcal{N}(v)|} \sum_{u \in \mathcal{N}(v)} x_u\right) + b<br>$$<br>• 对归一化后的邻居特征进行线性变换：<br>  • $W$ 是可学习的权重矩阵，用于将输入特征映射到新的特征空间。<br>  • $b$ 是可学习的偏置向量，用于调整特征的偏移。<br>• 这一步的目的是让模型能够学习到更复杂的特征表示。</p>
<p><strong>(4) 非线性激活</strong><br>$$<br>f\left(W \cdot \left(\frac{1}{|\mathcal{N}(v)|} \sum_{u \in \mathcal{N}(v)} x_u\right) + b\right)<br>$$<br>• 对线性变换的结果应用激活函数 $f(\cdot)$（如 ReLU），引入非线性。<br>• 非线性的引入使得模型能够捕捉更复杂的图结构信息。</p>
<p><strong>(5) 输出特征</strong><br>$$<br>h_v &#x3D; f\left(\frac{1}{|\mathcal{N}(v)|} \sum_{u \in \mathcal{N}(v)} W x_u + b\right)<br>$$<br>• 最终得到节点 $v$ 的输出特征 $h_v$，它是节点 $v$ 及其邻居节点特征的聚合结果，经过线性变换和非线性激活后的表示。</p>
<p><strong>3. 公式的特点</strong><br><strong>(1) 局部性</strong><br>• 该公式只考虑了节点 $v$ 的直接邻居节点的特征，而没有考虑更远的节点。这种局部性使得 GCN 能够捕捉图的局部结构信息。</p>
<p><strong>(2) 归一化</strong><br>• 通过 $\frac{1}{|\mathcal{N}(v)|}$ 的归一化操作，确保了不同节点的特征聚合结果不会因为邻居数量的差异而产生偏差。</p>
<p><strong>(3) 可学习性</strong><br>• 权重矩阵 $W$ 和偏置向量 $b$ 是可学习的，模型能够通过训练自动调整这些参数，从而适应不同的图结构和任务。</p>
<p><strong>(4) 非线性</strong><br>• 激活函数 $f(\cdot)$ 的引入使得模型能够捕捉非线性的图结构特征。</p>
<p><strong>4. 公式的改进与扩展</strong><br>在实际应用中，GCN 的公式可能会有一些改进和扩展，例如：<br><strong>(1) ChebNet（切比雪夫多项式近似）</strong><br>• 使用切比雪夫多项式来近似拉普拉斯矩阵的特征值分解，从而减少计算复杂度。<br>• 公式形式为：<br>$$<br>  h_v &#x3D; f\left(\sum_{k&#x3D;0}^K \theta_k T_k(\tilde{L}) x_v\right)<br>$$<br>  其中 $T_k(\cdot)$ 是切比雪夫多项式，$\tilde{L}$ 是归一化的拉普拉斯矩阵。</p>
<p><strong>(2) GraphSAGE</strong><br>• 在 GCN 的基础上引入了采样机制，支持大规模图的训练。<br>• 公式形式与 GCN 类似，但邻居节点的选择是动态的。</p>
<p><strong>(3) 无归一化的 GCN</strong><br>• 在某些情况下，可能会去掉归一化项 $\frac{1}{|\mathcal{N}(v)|}$，直接对邻居特征求和：<br>$$<br>  h_v &#x3D; f\left(\sum_{u \in \mathcal{N}(v)} W x_u + b\right)<br>$$</p>
<p>这段文字主要介绍了 <strong>GraphSAGE</strong> 的背景、动机以及其核心思想，特别是它如何解决 <strong>GCN</strong> 的两个主要缺点，并引入了 <strong>Inductive Learning</strong> 和 <strong>Transductive Learning</strong> 的概念。以下是对这段文字的逐层解读：</p>
<hr>
<h2 id="GCN的两个缺点"><a href="#GCN的两个缺点" class="headerlink" title="GCN的两个缺点"></a><strong>GCN的两个缺点</strong></h2><p>在介绍 GraphSAGE 之前，先明确 GCN 的两个主要缺点：</p>
<ol>
<li><p><strong>Transductive Learning（传导学习）</strong>：<br>• GCN 在训练时需要输入整个图，包括训练集、验证集和测试集的所有节点。<br>• 在训练过程中，GCN 会利用所有节点的邻居信息来更新节点的表示，这意味着测试集和验证集的节点信息也会被用来训练模型。<br>• 这种方式限制了 GCN 的泛化能力，因为它无法处理图中<strong>新加入的节点</strong>。</p>
</li>
<li><p><strong>无法处理动态图</strong>：<br>• GCN 的训练依赖于整个图的拓扑结构，因此当图中加入新节点或边时，需要重新训练整个模型。</p>
</li>
</ol>
<h3 id="1-Inductive-Learning-和-Transductive-Learning"><a href="#1-Inductive-Learning-和-Transductive-Learning" class="headerlink" title="1. Inductive Learning 和 Transductive Learning"></a><strong>1. Inductive Learning 和 Transductive Learning</strong></h3><p>为了更好地理解 GraphSAGE 的动机，需要先了解 <strong>Inductive Learning（归纳学习）</strong> 和 <strong>Transductive Learning（传导学习）</strong> 的区别：</p>
<h4 id="1-Transductive-Learning"><a href="#1-Transductive-Learning" class="headerlink" title="(1) Transductive Learning"></a><strong>(1) Transductive Learning</strong></h4><p>• <strong>定义</strong>：在训练过程中，模型会看到所有的样本（包括训练集、验证集和测试集），并通过这些样本之间的关系（如图中的边）来学习节点的表示。<br>• <strong>GCN 的问题</strong>：<br>  • GCN 是一个典型的 Transductive Learning 模型。<br>  • 在训练时，GCN 会利用测试集和验证集的节点信息来更新训练集节点的表示，这会导致模型在测试集上的表现可能过于依赖训练时的特定图结构。</p>
<h4 id="2-Inductive-Learning"><a href="#2-Inductive-Learning" class="headerlink" title="(2) Inductive Learning"></a><strong>(2) Inductive Learning</strong></h4><p>• <strong>定义</strong>：在训练过程中，模型只使用训练样本，训练样本和测试样本是完全分离的。<br>• <strong>GraphSAGE 的优势</strong>：<br>  • GraphSAGE 是一个 Inductive Learning 框架。<br>  • 在训练时，GraphSAGE 只使用训练样本的节点信息，而不需要访问测试集或验证集的节点。<br>  • 这种方式使得 GraphSAGE 能够处理动态图，并且可以为图中新加入的节点生成嵌入（embedding）。</p>
<h1 id="GraphSAGE-的核心思想"><a href="#GraphSAGE-的核心思想" class="headerlink" title="GraphSAGE 的核心思想"></a>GraphSAGE 的核心思想</h1><p>GraphSAGE 是为了解决 GCN 的上述问题而提出的，它的核心思想是<strong>归纳学习</strong>，即通过已知节点的信息为未知节点生成嵌入。</p>
<h2 id="1-关键步骤"><a href="#1-关键步骤" class="headerlink" title="1.关键步骤"></a>1.关键步骤</h2><p>以下是 GraphSAGE 的两个关键步骤：</p>
<h3 id="1-Sample（采样）"><a href="#1-Sample（采样）" class="headerlink" title="(1) Sample（采样）"></a><strong>(1) Sample（采样）</strong></h3><p>• <strong>问题</strong>：<br>  • 在图数据中，每个节点的邻居数量可能非常不均衡。例如，某些节点可能有成百上千个邻居，而另一些节点可能只有几个邻居。<br>  • 如果直接对所有邻居进行聚合，计算成本会非常高，尤其是当图的规模很大时。<br>• <strong>解决方法</strong>：<br>  • GraphSAGE 提出了<strong>邻居采样</strong>的方法，即在每次更新节点表示时，只随机选择一部分邻居节点进行聚合。<br>  • 这种方式显著降低了计算复杂度，同时仍然能够捕捉到图的全局结构信息。</p>
<h3 id="2-Aggregate（聚合）"><a href="#2-Aggregate（聚合）" class="headerlink" title="(2) Aggregate（聚合）"></a><strong>(2) Aggregate（聚合）</strong></h3><p>• <strong>问题</strong>：<br>  • 在聚合邻居节点的信息时，需要设计一种有效的机制来将这些邻居的嵌入信息整合到当前节点的表示中。<br>• <strong>解决方法</strong>：<br>  • GraphSAGE 提出了多种聚合函数（Aggregator），包括：<br>    1. <strong>均值聚合（Mean Aggregator）</strong>：<br>       ◦ 将邻居节点的嵌入取均值，作为当前节点的聚合结果。<br>        2. <strong>池化聚合（Pooling Aggregator）</strong>：<br>       ◦ 对邻居节点的嵌入进行池化操作（如最大池化、平均池化），以捕捉邻居节点的重要特征。<br>            3. <strong>LSTM 聚合（LSTM Aggregator）</strong>：<br>       ◦ 使用 LSTM 模型对邻居节点的嵌入进行序列建模，从而捕捉邻居节点的顺序信息。<br>                4. <strong>注意力机制聚合（Attention Aggregator）</strong>：<br>       ◦ 使用注意力机制为每个邻居节点分配不同的权重，从而更灵活地聚合邻居信息。</p>
<h2 id="2-GraphSAGE-的训练过程"><a href="#2-GraphSAGE-的训练过程" class="headerlink" title="2. GraphSAGE 的训练过程"></a><strong>2. GraphSAGE 的训练过程</strong></h2><p>GraphSAGE 的训练过程可以总结为以下几个步骤：</p>
<ol>
<li><strong>采样邻居节点</strong>：<br>• 对每个节点，随机采样一定数量的邻居节点。</li>
<li><strong>聚合邻居信息</strong>：<br>• 使用某种聚合函数（如均值、池化、LSTM 或注意力）将邻居节点的嵌入信息整合到当前节点的表示中。</li>
<li><strong>更新节点表示</strong>：<br>• 将聚合后的邻居信息与当前节点的特征进行结合（通常通过线性变换和非线性激活），生成新的节点表示。</li>
<li><strong>预测与优化</strong>：<br>• 使用生成的节点表示进行预测（如节点分类、链接预测等），并通过误差反向传播优化模型参数。</li>
</ol>
<h2 id="3-GraphSAGE-的优点"><a href="#3-GraphSAGE-的优点" class="headerlink" title="3. GraphSAGE 的优点"></a><strong>3. GraphSAGE 的优点</strong></h2><p>GraphSAGE 相较于 GCN 有以下几个显著优点：</p>
<ol>
<li><strong>Inductive Learning</strong>：<br>• GraphSAGE 是一个归纳学习框架，能够处理图中新加入的节点，而不需要重新训练整个模型。</li>
<li><strong>动态图支持</strong>：<br>• GraphSAGE 可以处理动态图，适应图中节点和边的变化。</li>
<li><strong>可扩展性</strong>：<br>• 通过邻居采样，GraphSAGE 显著降低了计算复杂度，适合大规模图数据。</li>
</ol>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h2><p>• <strong>GCN 的局限性</strong>：<br>  • GCN 是一个传导学习模型，训练时需要访问整个图，无法处理动态图和新加入的节点。<br>• <strong>GraphSAGE 的创新</strong>：<br>  • GraphSAGE 是一个归纳学习框架，通过邻居采样和聚合机制，能够高效地为图中新加入的节点生成嵌入。<br>• <strong>GraphSAGE 的核心</strong>：<br>  • <strong>Sample</strong>：对邻居节点进行采样。<br>  • <strong>Aggregate</strong>：聚合邻居节点的信息。</p>
<p>如果需要进一步探讨 GraphSAGE 的具体实现或与其他图神经网络模型的对比，请随时告诉我！</p>
<h3 id="公式结构"><a href="#公式结构" class="headerlink" title="公式结构"></a><strong>公式结构</strong></h3><p>$$<br>\alpha_{i,j} &#x3D; \frac{\exp\left(\text{LeakyReLU}\left(\vec{a}^T [W\vec{h}_i | W\vec{h}<em>j]\right)\right)}{\sum</em>{k \in N_i} \exp\left(\text{LeakyReLU}\left(\vec{a}^T [W\vec{h}_i | W\vec{h}_k]\right)\right)}<br>$$</p>
<h4 id="关键步骤解析"><a href="#关键步骤解析" class="headerlink" title="关键步骤解析"></a><strong>关键步骤解析</strong></h4><ol>
<li><p><strong>线性变换（共享权重）</strong><br>• 每个节点 $i$ 和其邻居节点 $j$ 的原始特征 $\vec{h}_i$ 和 $\vec{h}_j$ 通过共享的权重矩阵 $W$ 进行线性变换，得到 $W\vec{h}_i$ 和 $W\vec{h}_j$。<br>• <strong>作用</strong>：将原始特征映射到高维空间，增强表达能力。</p>
</li>
<li><p><strong>拼接与注意力得分计算</strong><br>• 将变换后的特征拼接为 $[W\vec{h}_i | W\vec{h}_j]$（维度从 $d$ 变为 $2d$）。<br>• 通过可学习的参数向量 $\vec{a}$（维度 $2d$）与拼接向量做点积，得到标量注意力得分：<br>$$<br>  \text{Score}(i,j) &#x3D; \vec{a}^T [W\vec{h}_i | W\vec{h}_j]<br>$$<br>• <strong>作用</strong>：衡量节点 $i$ 和 $j$ 之间的相关性。</p>
</li>
<li><p><strong>非线性激活与归一化</strong><br>• 对得分应用 <strong>LeakyReLU</strong> 激活函数（允许负值输入，缓解梯度消失）。<br>• 通过 <strong>Softmax</strong> 归一化：<br>$$<br>  \alpha_{i,j} &#x3D; \frac{\exp(\text{LeakyReLU}(\text{Score}(i,j)))}{\sum_{k \in N_i} \exp(\text{LeakyReLU}(\text{Score}(i,k)))}<br>$$<br>• <strong>作用</strong>：归一化权重，使 $\sum_{j \in N_i} \alpha_{i,j} &#x3D; 1$。</p>
</li>
</ol>
<h3 id="关键点说明"><a href="#关键点说明" class="headerlink" title="关键点说明"></a><strong>关键点说明</strong></h3><ol>
<li><p><strong>共享参数</strong><br>• 权重矩阵 $W$ 和参数向量 $\vec{a}$ <strong>对所有节点共享</strong>，减少参数量并增强模型泛化能力。</p>
</li>
<li><p><strong>分母修正</strong><br>• 原公式分母可能存在笔误，正确的求和项应为 $\sum_{k \in N_i} \exp(\text{LeakyReLU}(\vec{a}^T [W\vec{h}_i | W\vec{h}_k]))$，即用 $k$ 替换 $j$，确保归一化时遍历所有邻居节点。</p>
</li>
<li><p><strong>注意力机制的优势</strong><br>• 动态分配权重：根据节点特征自适应学习连接重要性，优于预定义的图结构权重（如邻接矩阵）。<br>• 局部性：仅计算节点与其邻居的权重，复杂度为 $O(|E|)$，适合大规模图数据。</p>
</li>
</ol>
<h3 id="示例计算"><a href="#示例计算" class="headerlink" title="示例计算"></a><strong>示例计算</strong></h3><p>假设节点 $i$ 的邻居为 ${j, k, l}$，特征维度 $d&#x3D;2$，则计算过程如下：</p>
<ol>
<li>对每个邻居 $j, k, l$，计算 $W\vec{h}_i$ 和 $W\vec{h}_j$，并拼接为 $4$ 维向量。  </li>
<li>通过 $\vec{a}^T$ 计算得分，应用 LeakyReLU。  </li>
<li>对得分取指数并归一化：<br>$$<br>\alpha_{i,j} &#x3D; \frac{\exp(s_{i,j})}{\exp(s_{i,j}) + \exp(s_{i,k}) + \exp(s_{i,l})}<br>$$</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h3><p>该公式用于图注意力网络的 <strong>消息传递</strong> 阶段，节点 $i$ 的新特征为其邻居特征的加权和：<br>$$<br>\vec{h}<em>i’ &#x3D; \sigma\left(\sum</em>{j \in N_i} \alpha_{i,j} W \vec{h}_j\right)<br>$$<br>其中 $\sigma$ 是非线性激活函数（如 ReLU）。</p>
<p>通过这一机制，图注意力网络能够显式建模节点间关系，适用于节点分类、链接预测等任务。</p>
<h3 id="DiffPool-详解：层次化图池化赋能图分类任务"><a href="#DiffPool-详解：层次化图池化赋能图分类任务" class="headerlink" title="DiffPool 详解：层次化图池化赋能图分类任务"></a><strong>DiffPool 详解：层次化图池化赋能图分类任务</strong></h3><h4 id="背景与问题"><a href="#背景与问题" class="headerlink" title="背景与问题"></a><strong>背景与问题</strong></h4><p>传统的图分类方法通常在图神经网络（GNN）后接全局池化（如求和、平均等），将所有节点嵌入压缩为一个向量。然而，这种做法忽略了图中潜在的<strong>层级结构</strong>，例如分子中的官能团或社交网络中的社区，导致模型难以捕捉多层次特征。<strong>DiffPool</strong>（Differentiable Pooling）由斯坦福团队提出，通过<strong>可微的层次化池化</strong>，逐步将细粒度节点聚合成粗粒度簇，构建多层抽象表示，显著提升图分类性能。</p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h3><p>DiffPool 的核心是<strong>逐层粗化图结构</strong>，每层包含两个关键操作：</p>
<ol>
<li><strong>分配矩阵生成</strong>：动态决定当前层节点如何分配到下一层的簇。</li>
<li><strong>图结构更新</strong>：根据分配结果，生成下一层的节点特征和邻接矩阵。</li>
</ol>
<p>通过堆叠多层，图从局部到全局的层级特征被逐层提取，最终通过顶层全局池化得到图的整体表示。</p>
<h3 id="分层池化步骤"><a href="#分层池化步骤" class="headerlink" title="分层池化步骤"></a><strong>分层池化步骤</strong></h3><h4 id="1-分配矩阵生成（关键：可微与动态）"><a href="#1-分配矩阵生成（关键：可微与动态）" class="headerlink" title="1. 分配矩阵生成（关键：可微与动态）"></a><strong>1. 分配矩阵生成（关键：可微与动态）</strong></h4><p>• <strong>输入</strong>：当前层的节点特征 $X^{(l)} \in \mathbb{R}^{N_l \times d}$ 和邻接矩阵 $A^{(l)} \in \mathbb{R}^{N_l \times N_l}$（$N_l$ 为当前层节点数）。</p>
<p>• <strong>过程</strong>：使用一个独立的GNN（称为 <strong>GNN_pool</strong>）生成分配矩阵 $S^{(l)} \in \mathbb{R}^{N_l \times N_{l+1}}$，其中 $N_{l+1}$ 是下一层的簇数：<br>$$<br>S^{(l)} &#x3D; \text{softmax}\left(\text{GNN}_\text{pool}(X^{(l)}, A^{(l)})\right)<br>$$<br>  • <strong>softmax</strong> 按行归一化，确保每个节点分配到各簇的概率和为1。</p>
<p>  • <strong>GNN_pool</strong> 学习节点到簇的映射关系，例如通过注意力机制或消息传递。</p>
<h4 id="2-节点特征聚合（粗化特征）"><a href="#2-节点特征聚合（粗化特征）" class="headerlink" title="2. 节点特征聚合（粗化特征）"></a><strong>2. 节点特征聚合（粗化特征）</strong></h4><p>• <strong>下一层节点特征</strong>：将当前层特征按簇加权聚合：<br>$$<br>X^{(l+1)} &#x3D; {S^{(l)}}^T \cdot \left(\text{GNN}_\text{embed}(X^{(l)}, A^{(l)})\right)<br>$$<br>  • <strong>GNN_embed</strong>：另一个GNN，用于更新节点特征，增强当前层的表示能力。</p>
<p>  • ${S^{(l)}}^T \cdot (\cdot)$ 表示按簇分配权重求和，得到粗粒度特征。</p>
<h4 id="3-邻接矩阵更新（粗化连接）"><a href="#3-邻接矩阵更新（粗化连接）" class="headerlink" title="3. 邻接矩阵更新（粗化连接）"></a><strong>3. 邻接矩阵更新（粗化连接）</strong></h4><p>• <strong>下一层邻接矩阵</strong>：计算簇之间的连接强度：<br>$$<br>  A^{(l+1)} &#x3D; {S^{(l)}}^T \cdot A^{(l)} \cdot S^{(l)}<br>$$<br>  • 若原图中节点 $i$ 和 $j$ 相连，则它们所属的簇 $c_i$ 和 $c_j$ 的连接强度累加 $S_{i,c_i} \cdot A_{i,j} \cdot S_{j,c_j}$。</p>
<h3 id="训练与优化"><a href="#训练与优化" class="headerlink" title="训练与优化"></a><strong>训练与优化</strong></h3><p>• <strong>端到端训练</strong>：所有GNN（GNN_pool 和 GNN_embed）与分类器共同训练。<br>• <strong>正则化项</strong>：<br>  • <strong>链路预测损失</strong>：鼓励相邻节点分配到同一簇：<br>    $$<br>    \mathcal{L}<em>\text{LP} &#x3D; | A^{(l)} - S^{(l)} \cdot {S^{(l)}}^T |<em>F<br>    $$<br>  • <strong>熵正则化</strong>：防止分配矩阵过于稀疏或稠密：<br>    $$<br>    \mathcal{L}<em>\text{Entropy} &#x3D; -\frac{1}{N_l} \sum</em>{i&#x3D;1}^{N_l} \sum</em>{c&#x3D;1}^{N</em>{l+1}} S_{i,c}^{(l)} \log S_{i,c}^{(l)}<br>    $$<br>• <strong>总损失</strong>：分类损失 + $\lambda_1 \mathcal{L}_\text{LP} + \lambda_2 \mathcal{L}_\text{Entropy}$。</p>
<h3 id="示例流程"><a href="#示例流程" class="headerlink" title="示例流程"></a><strong>示例流程</strong></h3><p>以分子图分类为例（层级：原子 → 官能团 → 分子）：</p>
<ol>
<li><strong>第1层</strong>：原始原子节点，GNN提取原子特征。</li>
<li><strong>第1次池化</strong>：GNN_pool 将原子分配到官能团簇，生成粗化特征和邻接矩阵。</li>
<li><strong>第2层</strong>：官能团作为节点，GNN学习官能团间相互作用。</li>
<li><strong>第2次池化</strong>：进一步聚合成分子整体表示，输入分类器预测标签。</li>
</ol>
<h3 id="优势与挑战"><a href="#优势与挑战" class="headerlink" title="优势与挑战"></a><strong>优势与挑战</strong></h3><p>• <strong>优势</strong>：<br>  • <strong>层次化表示</strong>：显式建模图的层级结构，适合复杂图数据。<br>  • <strong>端到端可微</strong>：无需预定义池化规则，适应多种任务。<br>  • <strong>灵活整合</strong>：可与任意GNN架构（如GCN、GAT）结合。</p>
<p>• <strong>挑战</strong>：<br>  • <strong>计算开销</strong>：矩阵乘法复杂度为 $O(N^2)$，大规模图受限。<br>  • <strong>超参数敏感</strong>：需预设每层簇数 $N_{l+1}$，影响模型表现。<br>  • <strong>训练稳定性</strong>：多任务损失需精细调参。</p>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/03/05/VLA%20%E7%BB%BC%E8%BF%B0%E9%98%85%E8%AF%BB/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#title-%E2%80%9D%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%9Ddata-2025-3-5author-%E2%80%9D%E6%9C%B1%E5%AE%87%E9%98%B3%E2%80%9D"><span class="nav-number">1.</span> <span class="nav-text">title:”图神经网络”data:2025-3-5author:”朱宇阳”</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0"><span class="nav-number"></span> <span class="nav-text">图神经网络概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GCN"><span class="nav-number"></span> <span class="nav-text">GCN</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E9%A1%B6%E7%82%B9%E5%9F%9F%EF%BC%88%E7%A9%BA%E9%97%B4%E5%9F%9F%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">一.顶点域（空间域）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A%E7%A9%BA%E5%9F%9F%E5%8D%B7%E7%A7%AF"><span class="nav-number">1.1.</span> <span class="nav-text">1. 核心概念：空域卷积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%85%B8%E5%9E%8B%E6%96%B9%E6%B3%95%EF%BC%9A%E7%A9%BA%E5%9F%9F%E5%8D%B7%E7%A7%AF%E7%9A%84%E4%BB%A3%E8%A1%A8%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.2.</span> <span class="nav-text">2. 典型方法：空域卷积的代表模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Message-Passing-Neural-Networks-MPNN-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">(1) Message Passing Neural Networks (MPNN) [1]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-GraphSAGE-2"><span class="nav-number">1.2.2.</span> <span class="nav-text">(2) GraphSAGE [2]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Diffusion-Convolution-Neural-Networks-DCNN-3"><span class="nav-number">1.2.3.</span> <span class="nav-text">(3) Diffusion Convolution Neural Networks (DCNN) [3]</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-PATCHY-SAN-4"><span class="nav-number">1.2.4.</span> <span class="nav-text">(4) PATCHY-SAN [4]</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-spectral-domain%EF%BC%9A%E9%A2%91%E5%9F%9F%E6%96%B9%E6%B3%95%EF%BC%88%E8%B0%B1%E6%96%B9%E6%B3%95%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">二. spectral domain：频域方法（谱方法）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9F%BA%E7%A1%80%E5%AF%BC%E5%BC%95"><span class="nav-number">2.1.</span> <span class="nav-text">1.基础导引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89-%E9%A2%91%E5%9F%9F%E6%96%B9%E6%B3%95%E4%B8%8B%E5%9B%BE%E5%8D%B7%E7%A7%AF%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8E%A8%E5%AF%BC"><span class="nav-number">3.</span> <span class="nav-text">三.频域方法下图卷积网络的推导</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%9F%A9%E9%98%B5"><span class="nav-number">3.1.</span> <span class="nav-text">1.拉普拉斯矩阵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%AE%97%E5%AD%90"><span class="nav-number">3.2.</span> <span class="nav-text">2. 拉普拉斯算子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%A6%BB%E6%95%A3%E5%BD%A2%E5%BC%8F%E7%9A%84%E4%B8%80%E7%BB%B4%E5%8D%B7%E7%A7%AF"><span class="nav-number">3.3.</span> <span class="nav-text">3. 离散形式的一维卷积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="nav-number">3.4.</span> <span class="nav-text">4. 傅里叶变换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E8%BF%9E%E7%BB%AD%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="nav-number">3.4.1.</span> <span class="nav-text">4.1 连续形式的傅立叶变换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-1-%E5%A6%82%E4%BD%95%E7%9B%B4%E8%A7%82%E5%9C%B0%E7%90%86%E8%A7%A3%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%9F"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">4.1.1 如何直观地理解傅立叶变换？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0%E4%B8%8E%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="nav-number">3.4.2.</span> <span class="nav-text">4.2傅里叶级数与傅里叶变换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-1-%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0%E7%9A%84%E4%B8%89%E8%A7%92%E5%BD%A2%E5%BC%8F"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">4.2.1 傅里叶级数的三角形式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-2-%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0%E7%9A%84%E5%A4%8D%E6%8C%87%E6%95%B0%E5%BD%A2%E5%BC%8F"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">4.2.2 傅里叶级数的复指数形式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3%E3%80%81%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="nav-number">3.4.3.</span> <span class="nav-text">4.3、傅里叶变换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-1-%E4%B8%80%E7%BB%B4%E8%BF%9E%E7%BB%AD%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">4.3.1 一维连续傅里叶变换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-2-%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">4.3.2 傅里叶变换与傅里叶级数的关系</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCN%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%BC%BA%E7%82%B9"><span class="nav-number">4.</span> <span class="nav-text">GCN的两个缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Inductive-Learning-%E5%92%8C-Transductive-Learning"><span class="nav-number">4.1.</span> <span class="nav-text">1. Inductive Learning 和 Transductive Learning</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Transductive-Learning"><span class="nav-number">4.1.1.</span> <span class="nav-text">(1) Transductive Learning</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Inductive-Learning"><span class="nav-number">4.1.2.</span> <span class="nav-text">(2) Inductive Learning</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GraphSAGE-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number"></span> <span class="nav-text">GraphSAGE 的核心思想</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.</span> <span class="nav-text">1.关键步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Sample%EF%BC%88%E9%87%87%E6%A0%B7%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">(1) Sample（采样）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Aggregate%EF%BC%88%E8%81%9A%E5%90%88%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">(2) Aggregate（聚合）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-GraphSAGE-%E7%9A%84%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">2. GraphSAGE 的训练过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-GraphSAGE-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">3.</span> <span class="nav-text">3. GraphSAGE 的优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%80%BB%E7%BB%93"><span class="nav-number">4.</span> <span class="nav-text">4. 总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">公式结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E6%AD%A5%E9%AA%A4%E8%A7%A3%E6%9E%90"><span class="nav-number">4.1.1.</span> <span class="nav-text">关键步骤解析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9%E8%AF%B4%E6%98%8E"><span class="nav-number">4.2.</span> <span class="nav-text">关键点说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E8%AE%A1%E7%AE%97"><span class="nav-number">4.3.</span> <span class="nav-text">示例计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.4.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DiffPool-%E8%AF%A6%E8%A7%A3%EF%BC%9A%E5%B1%82%E6%AC%A1%E5%8C%96%E5%9B%BE%E6%B1%A0%E5%8C%96%E8%B5%8B%E8%83%BD%E5%9B%BE%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1"><span class="nav-number">4.5.</span> <span class="nav-text">DiffPool 详解：层次化图池化赋能图分类任务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%83%8C%E6%99%AF%E4%B8%8E%E9%97%AE%E9%A2%98"><span class="nav-number">4.5.1.</span> <span class="nav-text">背景与问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="nav-number">4.6.</span> <span class="nav-text">核心思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E6%B1%A0%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="nav-number">4.7.</span> <span class="nav-text">分层池化步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%86%E9%85%8D%E7%9F%A9%E9%98%B5%E7%94%9F%E6%88%90%EF%BC%88%E5%85%B3%E9%94%AE%EF%BC%9A%E5%8F%AF%E5%BE%AE%E4%B8%8E%E5%8A%A8%E6%80%81%EF%BC%89"><span class="nav-number">4.7.1.</span> <span class="nav-text">1. 分配矩阵生成（关键：可微与动态）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%8A%82%E7%82%B9%E7%89%B9%E5%BE%81%E8%81%9A%E5%90%88%EF%BC%88%E7%B2%97%E5%8C%96%E7%89%B9%E5%BE%81%EF%BC%89"><span class="nav-number">4.7.2.</span> <span class="nav-text">2. 节点特征聚合（粗化特征）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E6%9B%B4%E6%96%B0%EF%BC%88%E7%B2%97%E5%8C%96%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="nav-number">4.7.3.</span> <span class="nav-text">3. 邻接矩阵更新（粗化连接）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%AD%E7%BB%83%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="nav-number">4.8.</span> <span class="nav-text">训练与优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E6%B5%81%E7%A8%8B"><span class="nav-number">4.9.</span> <span class="nav-text">示例流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8A%BF%E4%B8%8E%E6%8C%91%E6%88%98"><span class="nav-number">4.10.</span> <span class="nav-text">优势与挑战</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yarn"
      src="/images/me.png">
  <p class="site-author-name" itemprop="name">Yarn</p>
  <div class="site-description" itemprop="description">Yarn的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yuyangzhu7" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yuyangzhu7" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yuyangzhu@std.uestc.edu.cn" title="E-Mail → mailto:yuyangzhu@std.uestc.edu.cn" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        


<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yarn</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

<div class="powered-by">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" site-pv-id="https://yuyangzhu7.github.io"></script>
    <i class="fa fa-user-md"></i>
    <span id="busuanzi_container_site_uv">
    |
        本站访客数:<span id="busuanzi_value_site_uv"></span>
    </span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_pv">
        本站访问量<span id="busuanzi_value_site_pv"></span>
    </span>
</div>



<div class="theme-info">
  |
  <div class="powered-by"></div>
  <span class="post-count">博客全站共16.4k字</span>
</div>
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
